# DI序列的有效排列

dp[i][n]表示排列到S[i]处时({0, 1, ..., i}的长度为i+1)结尾取值为n的排列个数.

- 当下一个即第i个字符为D时,首先显然,数字j只能排在j+1、j+2...i-1之后,故我们有:
dp[i][j] = dp[i-1][j+1] + dp[i-1][j+2] + ... + dp[i-1][i-1].
当然这可能会出现数字重复的问题,但由于增加了新的数字i,所以在原来的排列的基础上我们能够对数字做出一些调整,即将大于等于j的数字全部加一,
就可以在末尾再放上数字j.如此一来,dp[i-1][j]所代表的排列也能够算到这里,所以最后我们有:
   ```
   dp[i][j] = dp[i-1][j] + dp[i-1][j+1] + dp[i-1][j+2] + ... + dp[i-1][i-1].
   ```
   - e.g.排列1,4,2,0,3,下一个字符为D,当要在末尾加上3的时候,我们将原排列中大于等于3的数加一,再加上3,可得排列1,5,2,0,4,3;
   
- 当下一个即第i个字符为I时,与D的情况相反,数字j只能排在j-1、j+2...0之后,故我们有:
dp[i][j] = dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][0].
当数字重复出现时将大于等于j的数字加一再在末尾放上数字j.当然,若j=0,dp[i][j]=0.所以排除0的情况我们有:
   ```
   dp[i][j] = dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][0]
   ```
   - e.g.排列1,4,2,0,3,下一个字符为I,要在末尾加上4的时候,我们将原排列中大于等于4的数加一,再加上4,可得排列1,5,2,0,3,4.
   
```cpp
class Solution {
public:
    int numPermsDISequence(string S) {
        int M = pow(10, 9)+7;
        vector<vector<int>> dp(S.size()+1, vector<int>(S.size()+1, 0));
        dp[0][0] = 1;
        for(int i=0; i<S.size(); i++){
            if(S[i] == 'I'){
                for(int j=1; j <= i+1; j++){
                    dp[i+1][j] = (dp[i+1][j-1] + dp[i][j-1]) % M;
                }
            }else{
                for(int j=i; j>=0; j--){
                    dp[i+1][j] = (dp[i+1][j+1] + dp[i][j]) % M;
                }
            }
        }
        int res = 0;
        for(int i=0; i<=S.size(); i++){
            res = (res + dp[S.size()][i]) % M;
        }
        return res;
    }
};
```
